/**
 * 观察者模式
 * 定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，
 * 所有依赖于它的对象都的到通知并被自动更新。
 * 一对多模式
 * 步骤
 * 一、目标对象的定义
 * 二、具体的目标对象的定义
 * 三、再来看看观察者的接口定义
 * 四、看看观察者的具体实现
 *
 * 认识观察者模式
 * 六大方面
 * 第一 目标与观察者之间的关系
 *  -- 一对一关系（黄明的天气 <--->黄明的女朋友）
 *  -- 一对多关系（黄明的天气 <--->黄明的女朋友，黄明的老妈）
 *  -- 多对一关系（黄明的天气，黄明的报纸 <--->黄明的女朋友）
 *
 * 第二 单向依赖
 *
 * 第三 命名建议
 *  -- 目标接口的定义， 建议在名称后面跟Subject
 *  -- 观察者接口的定义， 建议在名称后面跟Observer
 *  -- 观察者接口的更新方法， 建议名称为update
 * 第四 触发通知的时机
 *  --
 * 第五 观察者模式的调用顺序示意图
 *  --
 * 第六 通知的顺序
 *  --
 * 实现的两种方式：推模型和拉模型
 *  -- 推模型
 *  目标对象主动向观察者推送目标的详细信息
 *  推送的信息通常是目标对象的全部或部分数据
 *
 *  -- 拉模型
 *   目标对象在通知观察者的时候， 只传递少量信息
 *   如果观察者需要更具体的信息， 由观察者主动到目标对象中获取， 相当于是观察者从目标对象中拉数据。
 *   一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者
 * 两种模型做个比较
 *  -比较
 *  --推模型是假定目标对象知道观察者需要的数据
 *  --拉模型是目标对象不知道观察者具体需要什么数据，因此把自身传给观察者，由观察者来取值
 *  --推模型会使观察者对象难以复用
 *  --拉模型下，update方法的参数是目标对象本身， 基本上可以适应各种情况的需要
 * 利用java提供的观察者实现
 * java.util包
 * Observable类
 * 接口Observer
 * update()方法
 * Java实现与自己实现的对比
 * 四点
 * 第一 不需要再定义观察者和目标接口了，JDK帮忙定义了
 * 第二 具体的目标实现里面不需要再维护观察者的注册信息了，这个在Java中的Observable类里面，已经帮忙实现好了。
 * 第三 触发通知的方式有一点变化，要先调用setChanged方法，这个是Java为了帮助实现更精确的触发控制而提供的功能。
 * 第四 具体观察者的实现里面，update方法其实能同时支持推模型和拉模型， 这个是Java在定义的时候， 就已经考虑进去了。
 * 观察者的优点
 * 第一 观察者模式实现了观察者和目标之间的抽象耦合
 * 第二 观察者模式实现了动态联动
 * 第三 观察者模式支持广播通信
 * 观察者的缺点
 * 可能会引起无谓的操作
 * 何时使用观察者模式
 * 触发联动 观察者模式的本质
 * 建议在以下情况中选用观察者模式
 * 第一 当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化
 * 第二 如果在更改一个对象的时候，需要同时连带改变其他对象，而且不知道究竟应该有多少对象需要被连带改变
 * 第三 当一个对象必须通知其他的对象，但是你又希望这个对象和其他被它通知的对象是松散耦合的。
 * 示例的实现步骤
 * 1.定义目标的抽象类和观察者的接口
 * 2.实现目标的类和观察者接口
 * 3.进行测试
 *
 *
 *
 *
 * @author : Huang Vector ( hgw )
 * @Date : 2018-6-8 11:42
 */
package cn.vector.pattern.observer;